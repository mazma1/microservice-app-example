node {
  stage('git checkout') {
    git branch: 'deploy-k8s-gcp', url: 'https://github.com/mazma1/microservice-app-example'
  }

  stage('archive') {
    archiveArtifacts artifacts: '*, log-message-processor/'
  }

  stage('build image') {
    sh '''
      cd ${WORKSPACE}/log-message-processor
      REPO="log-message-processor"
      #Build container images using Dockerfile
      docker build --no-cache -t ${REPO}:${BUILD_NUMBER} .
    '''
  }

  stage('login to gcr') {
    withCredentials([string(credentialsId: 'GCLOUD-SERVICE-KEY', variable: 'GCLOUD_SERVICE_KEY')]) {
      sh '''
        echo $GCLOUD_SERVICE_KEY | base64 --decode --ignore-garbage > ${WORKSPACE}/gcloud-service-key.json
        docker login -u _json_key -p "$(cat ${WORKSPACE}/gcloud-service-key.json)" https://gcr.io
      '''
    }
  }

  stage('push image to GCR') {
    withCredentials([string(credentialsId: 'REGISTRY-URL', variable: 'REGISTRY_URL')]) {
      sh '''
        REG_ADDRESS="${REGISTRY_URL}"
        REPO="log-message-processor"
        #Tag the build with BUILD_NUMBER version
        docker tag ${REPO}:${BUILD_NUMBER} ${REG_ADDRESS}/${REPO}:${BUILD_NUMBER}
        #Publish image
        docker push ${REG_ADDRESS}/${REPO}:${BUILD_NUMBER}
      '''
    }
  }

  stage('deploy to Kubernetes cluster') {
    withCredentials(
      [string(credentialsId: 'REGISTRY-URL', variable: 'REGISTRY_URL'),
      string(credentialsId: 'CLUSTER-NAME', variable: 'CLUSTER_NAME'),
      string(credentialsId: 'SERVER-URL', variable: 'SERVER_URL')
    ]) {
      withKubeConfig(caCertificate: '', contextName: "${CLUSTER_NAME}", credentialsId: 'KUBERNETES', serverUrl: "${SERVER_URL}") {
          
        sh '''
          REPO="log-message-processor"
          DEPLOYMENTS=$(kubectl get deployment -o=jsonpath='{.items[*].metadata.name}')
          DEPLOYMENT_BASE_PATH="${WORKSPACE}/k8s"
          NEW_SERVICE_IMAGE="${REGISTRY_URL}/${REPO}:${BUILD_NUMBER}"
          
          SERVICE_FOUND=$(echo ${DEPLOYMENTS} | grep "${REPO}") || :
  
          if [ -z "${SERVICE_FOUND}" ]; then
              echo "${REPO} does not exist, about to deploy service"

              DEPLOYMENT_FILE="${DEPLOYMENT_BASE_PATH}/${REPO}/deployment.yaml"

              # update deployment file with image published in build, then create deployment
              sed -i 's|$SERVICE_DOCKER_IMAGE|'"$NEW_SERVICE_IMAGE"'|' "${DEPLOYMENT_FILE}"
              kubectl create -f "${DEPLOYMENT_FILE}"
          else
              echo "${REPO} deployment already exists, about to deploy an update"
              kubectl set image deployment/log-message-processor log-message-processor=${NEW_SERVICE_IMAGE}
          fi
        '''
      }
    }
  }
}